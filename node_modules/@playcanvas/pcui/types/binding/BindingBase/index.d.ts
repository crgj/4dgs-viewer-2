import { Events, History, Observer } from '@playcanvas/observer';
import { IBindable } from '../../components/Element';
/**
 * The interface for arguments for the {@link BindingBase} constructor.
 */
export interface BindingBaseArgs {
    /**
     * The IBindable element.
     */
    element?: IBindable;
    /**
     * The history object which will be used to record undo / redo actions.
     * If none is provided then no history will be recorded.
     */
    history?: History;
    /**
     * A prefix that will be used for the name of every history action.
     */
    historyPrefix?: string;
    /**
     * A postfix that will be used for the name of every history action.
     */
    historyPostfix?: string;
    /**
     * The name of each history action.
     */
    historyName?: string;
    /**
     * Whether to combine history actions.
     */
    historyCombine?: boolean;
}
/**
 * Base class for data binding between {@link IBindable} {@link Element}s and Observers.
 */
declare class BindingBase extends Events {
    protected _observers: Observer[];
    protected _paths: string[];
    protected _applyingChange: boolean;
    protected _element?: IBindable;
    protected _history?: History;
    protected _historyPrefix?: string;
    protected _historyPostfix?: string;
    protected _historyName?: string;
    protected _historyCombine: boolean;
    protected _linked: boolean;
    /**
     * Creates a new binding.
     *
     * @param args - The arguments.
     */
    constructor(args: Readonly<BindingBaseArgs>);
    protected _pathAt(paths: string[], index: number): string;
    /**
     * Links the specified observers to the specified paths.
     *
     * @param observers - The observer(s).
     * @param paths - The path(s). The behavior of the binding depends on how many paths are passed.
     * If an equal amount of paths and observers are passed then the binding will map each path to each observer at each index.
     * If more observers than paths are passed then the path at index 0 will be used for all observers.
     * If one observer and multiple paths are passed then all of the paths will be used for the observer (e.g. for curves).
     */
    link(observers: Observer | Observer[], paths: string | string[]): void;
    /**
     * Unlinks the observers and paths.
     */
    unlink(): void;
    /**
     * Clones the binding. To be implemented by derived classes.
     */
    clone(): BindingBase;
    /**
     * Sets a value to the linked observers at the linked paths.
     *
     * @param value - The value
     */
    setValue(value: any): void;
    /**
     * Sets an array of values to the linked observers at the linked paths.
     *
     * @param values - The values.
     */
    setValues(values: any[]): void;
    /**
     * Adds (inserts) a value to the linked observers at the linked paths.
     *
     * @param value - The value.
     */
    addValue(value: any): void;
    /**
     * Adds (inserts) multiple values to the linked observers at the linked paths.
     *
     * @param values - The values.
     */
    addValues(values: any[]): void;
    /**
     * Removes a value from the linked observers at the linked paths.
     *
     * @param value - The value.
     */
    removeValue(value: any): void;
    /**
     * Removes multiple values from the linked observers from the linked paths.
     *
     * @param values - The values.
     */
    removeValues(values: any[]): void;
    /**
     * Sets the element.
     */
    set element(value: IBindable | undefined);
    /**
     * Gets the element.
     */
    get element(): IBindable | undefined;
    /**
     * Sets whether the binding is currently applying a change, either to the observers or the element.
     */
    set applyingChange(value: boolean);
    /**
     * Gets whether the binding is currently applying a change, either to the observers or the element.
     */
    get applyingChange(): boolean;
    /**
     * Gets whether the binding is linked to observers.
     */
    get linked(): boolean;
    /**
     * Sets whether to combine history actions when applying changes to observers. This is assuming
     * a history module is being used.
     */
    set historyCombine(value: boolean);
    /**
     * Gets whether to combine history actions when applying changes to observers.
     */
    get historyCombine(): boolean;
    /**
     * Sets the name of the history action when applying changes to observers.
     */
    set historyName(value: string);
    /**
     * Gets the name of the history action when applying changes to observers.
     */
    get historyName(): string;
    /**
     * Sets the string to prefix {@link historyName} with.
     */
    set historyPrefix(value: string);
    /**
     * Gets the string to prefix {@link historyName} with.
     */
    get historyPrefix(): string;
    /**
     * Sets the string to postfix {@link historyName} with.
     */
    set historyPostfix(value: string);
    /**
     * Gets the string to postfix {@link historyName} with.
     */
    get historyPostfix(): string;
    /**
     * Sets whether history is enabled for the binding. A valid history object must have been provided first.
     */
    set historyEnabled(value: any);
    /**
     * Gets whether history is enabled for the binding.
     */
    get historyEnabled(): any;
    /**
     * Gets the linked observers.
     */
    get observers(): Observer[];
    /**
     * Gets the linked paths.
     */
    get paths(): string[];
}
export { BindingBase };
